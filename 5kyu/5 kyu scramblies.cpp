//Complete the function scramble(str1, str2) that returns true if a portion of str1 characters can be rearranged to match str2, otherwise returns false.
//
//Notes:
//
//Only lower case letters will be used(a - z).No punctuation or digits will be included.
//Performance needs to be considered.
//Examples
//scramble('rkqodlw', 'world') ==> True
//scramble('cedewaraaossoqqyt', 'codewars') ==> True
//scramble('katas', 'steak') ==> False






#include <string>
#include <unordered_map>
using namespace std;

bool scramble(const string& s1, const string& s2) {
    // Создаем хэш-таблицу для подсчета количества встречающихся символов в строке s1
    unordered_map<char, int> charCount;

    // Заполняем хэш-таблицу символами из строки s1
    for (char c : s1)
        charCount[c]++; // Увеличиваем счетчик встреченного символа

    // Проверяем, содержит ли s1 достаточно символов для s2
    for (char c : s2) {
        // Если символ отсутствует в хэш-таблице или его количество в s1 меньше, чем в s2, возвращаем false
        if (charCount.find(c) == charCount.end() || --charCount[c] < 0)
            return false; // Возвращаем false, если символ не найден или его количество в s1 недостаточно
    }
    
    return true; // Возвращаем true, если все символы s2 найдены в s1 в достаточном количестве
}







///////////////////ЧТО ТАКОЕ Хеш-таблица////////////////////////

//Хеш-таблица - это как ящик с ярлыками, где вы можете быстро найти нужный ярлык, зная что на нём написано.Например, у вас есть ящик, в котором много ярлыков с разными словами, и вы хотите быстро найти ярлык с определенным словом, скажем, "яблоко".
//Вот как это работает :
//Создание ящика :
//Сначала вы создаете пустой ящик(хеш - таблицу).
//Подготовка ярлыков :
//Вы берете слово "яблоко" (ваш ключ) и применяете к нему хэш - функцию.Это как магическое преобразование, которое превращает слово "яблоко" в число(хэш), например, 5.
//Теперь вы знаете, что ярлык со словом "яблоко" должен быть в коробке номер 5.
//Помещение ярлыка в ящик :
//Вы кладете ярлык с словом "яблоко" в коробку под номером 5.
//Поиск ярлыка :
//Теперь, когда вам нужно найти ярлык с словом "яблоко", вы снова применяете хэш - функцию к слову "яблоко" и получаете число 5.
//Затем вы знаете, что в коробке под номером 5 есть ваш ярлык с "яблоко".
//Коллизии :
//    Но что если у вас есть несколько слов, которые превращаются в одно и то же число ? Например, и "яблоко", и "автобус" превращаются в число 5.
//    В этом случае, у вас будет коробка с несколькими ярлыками.Это называется коллизией.
//    Решение коллизий :
//Есть разные способы решения коллизий.Например, вы можете создать список внутри коробки, где будет храниться несколько ярлыков.
//Теперь, когда вы ищете ярлык с "яблоко", вам нужно просто проверить список в коробке номер 5.


//Вот пример
//#include <iostream>
//#include <string>
//#include <unordered_map>
//
//using namespace std;
//
//int main() {
//    // Создаем хеш-таблицу, где ключом является слово, а значением - номер коробки
//    unordered_map<string, int> ящики;
//
//    // Помещаем ярлык "яблоко" в коробку номер 5
//    ящики["яблоко"] = 5;
//
//    // Находим ярлык "яблоко"
//    cout << "Номер коробки для ярлыка с яблоком: " << ящики["яблоко"] << endl;
//
//    return 0;
//}







       /////////////////////old solution/////////////////
//#include<string>
//using namespace std;
//
//bool scramble(const string& s1, const string& s2) {
//    string ss1 = s1;
//    size_t result = s2.length();
//
//
//    for (char a : s2) {
//
//        for (size_t i = 0; i <= ss1.length(); i++) {
//
//            if (a == ss1[i]) {
//                result--;
//                ss1.erase(i, 1);
//                break;
//            }
//
//        }
//
//    }
//
//    return result == 0;
//
//}